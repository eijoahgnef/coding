# 原型 和 原型链
每个对象都拥有一个原型对象，对象以其为模板，从原型继承方法和属性。原型对象也可能拥有原型，也从中继承属性和方法，这种一层一层的关系，称为原型链。

原型又可分为显示原型(ptototype)和隐式原型(__ptoto__)，在浏览器中隐式原型是[[prototype]]这样表示(后面改的)。隐式原型指向构造函数的原型对象，也就是构造函数的显示原型。隐式原型是实例上的属性。

# 原型链的作用
原型链主要用于继承，其实就是为了代码复用。js算不上是面向对象的语言，继承是基于原型实现而不是基于类实现的。

# new  new.js
new用于创建一个用户自定义的对象类型的实例或具有构造函数的内置对象的实例
new 关键字会进行四步操作
1. 创建一个空对象
2. 为这个空对象添加一个__proto__属性，这个属性指向构造函数的原型对象
3. 将这个空对象的作为this的上下文
4. 如果该对象没有返回对象，则返回this

# 继承
利用原型让一个引用类型继承另一个引用类型的属性和方法

1. 原型链继承  1.js (纯原型链手段)
缺点：
- 原型实际上会变成另一个类型的实例，并且这个实例中的属性会被所有的子类实例所共享
- 在创建子类型的实例时，做不到向超类型的构造函数传参

2. 构造函数继承（经典继承） 2.js (call)
缺点：
- 子类实例无法继承到超类构造函数原型上的属性和方法
- 所有的属性和方法都只能写在构造函数内部，降低了代码的复用性

3. 组合继承（伪经典继承）  3.js  (原型链+call)
缺点：
- 超类构造函数无论何时，都要被调用两次

4. 原型式继承  4.js  (create)
单纯的对象之间继承可以胜任
缺点：
- 包含引用类型值的属性始终会共享

5. 寄生式继承 5.js
缺点：
-做不到函数的复用

6. 寄生组合式继承   6.js
