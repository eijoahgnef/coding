# let 和 const
> 用法类似于var，但是所声明的变量只在代码块内有效。
> const一旦声明了变量，就必须立刻初始化，不能留到以后赋值。它声明的是一个只读的常量，一旦声明常量的值就不能改变，这里说的不能改变说的是栈上这个变量所对应的那个值，如果是基础数据类型，那么这个变量就是一个常量，如果是引用数据类型，能改变的仅仅是它对应的堆上地址的那块数据。
# var、let 和 const 的区别
- 变量提升、暂时性死区、块级作用域、重复声明、修改声明的变量。在开发中，尽量使用const和let，避免使用var。
- 暂时性死区，就是在还没声明变量的时候，就对其进行了引用。

# 变量的结构赋值
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。
- 数组的解构赋值  1.js
注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
- 对象的解构赋值  2.js
对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果结构失败值就为undefined。
注意：如果要将一个已经声明的变量用于解构赋值，必须非常小心。

# 字符串的扩展
- 就字符串自身而言
    - 遍历器接口，可用for...of循环遍历
    - 模板字符串：无需换行符，可以多行字符串，且在字符串中嵌入变量
- 字符串新增的方法，
    - includes(string, ?index): 返回布尔值，表示是否找到了参数字符串
    - startsWith(string, ?index): 返回布尔值，表示参数字符串是否在原字符串的头部
    - endsWith(string, ?index): 返回布尔值，表示参数字符串是否在原字符串的尾部
    - string.repeat(n): 表示将原字符串重复n次

# 数值的扩展
- 方法的扩展：
    - Number.isFinite()：用来检查一个数值是否为有限的（finite），即不是Infinity。
    - Number.isNaN()：用来检查一个值是否为NaN，只有对于NaN才返回true，非NaN一律返回false。
    它与传统的全局方法isNaN()对比，isNaN()会先调用Number()将非数值转为数值再进行判断
    - Number.parseInt(), Number.parseFloat()：ES6将这两个全局方法移植到了Number对象上，行为完全保持不变
- Math的扩展：
    - Math.trunc：用于去除一个数的小数部分，返回整数部分
    - Math.sign：用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

# 对象的扩展
- 属性的扩展：
    - Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
    - Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
- 扩展运算符（...）
    - 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
    - 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
    - 如果扩展运算符后面是一个空对象，则没有任何效果。如果扩展运算符后面不是对象，则会自动将其转为对象。
- 新增的方法
    - Object.is()：ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
    ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
    不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
    - Object.assign()：用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign(target,sourse1,sourse2...)
        - Object.assign()方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
        - 一旦遇到同名属性，Object.assign()的处理方法是替换，而不是添加。
    - __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf(): 用来设置一个对象的原型对象和用来读取一个对象的原型对象

# 函数的扩展
- 函数参数的默认值：可以给参数赋默认值
- 箭头函数：
    - 箭头函数没有自己的this对象
    - 不可以当做构造函数，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误
    - 不可以使用arguments对象，该对象在函数体内不存在。
    - 不可以使用yield命令，因此箭头函数不能用作Generator函数
- 函数的尾调用优化
    - 尾调用：指某个函数的最后一步是调用另一个函数
    - 优化：
    > 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
    > 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。
    这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
    - 尾递归优化的实现  trampoline.js

# Set 
> 它类似于数组，但是成员值都是唯一的，没有重复的值。可接收一个数组或者类数组作为参数。
- 作用：数组去重，字符串去重
    - 数组去重可以用 [...new Set(array)] 或者 Array.from(new Set(array))
    - 字符串去重：Array.from(new Set(string)).join('')
- 属性和方法：
    - Set.prototype.size: 返回set的成员数
    - Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
    - Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
    - Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
    - Set.prototype.clear()：清除所有成员，没有返回值。
    - forEach(item, index, set)
    - for...of
- weakSet：与Set有两个区别，WeakSet的成员只能是对象，其次就是weakset中的对象都是弱引用，即垃圾回收机制不考虑weakset对该对象的引用
    - 没有size属性，forEach无法遍历

# Map
> ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
- 属性和方法：
    - size：返回Map结构的成员数
    - Map.prototype.set(key, value)：如果key有值，则键值会被更新，否则就新生成该键。该方法返回的是当前的Map对象，因此可以采用链式写法。
    - Map.prototype.get(key)：读取key对应的键值，如果找不到key，就会返回undefined。
    - Map.prototype.has(key)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。
    - Map.prototype.delete(key)：删除某个键，返回true。如果删除失败，返回false。
    - Map.prototype.clear()：清除所有成员，没有返回值。
- 遍历方法： 
    - Map.prototype.keys()：返回键名的遍历器。
    - Map.prototype.values()：返回键值的遍历器。
    - Map.prototype.entries()：返回所有成员的遍历器。
    - Map.prototype.forEach()：遍历 Map 的所有成员。
- 相关使用
    - Map结构转为数组结构，比较快速的方法是使用扩展运算符。[...map]
    - 数组转为Map，直接将数值传入Map构造函数，就可以转为Map。new Map([array1, array2...]),这里注意，传入的数组只取前两个作为key和value，如果是空数组或者是长度为一的数组，缺少的值就用undefined填充。
    - Map转为对象：如果所有的Map的键都是字符串，它可以无损地转为对象，如果有非字符串的键名，那么这个键名会被转换成字符串，再作为对象的键名。
    - 对象转为Map：可以通过Object.entries()，也可以自己实现一个转换函数。
- WeakMap: 与Map结构类似，也是用于生成键值对的集合。
    - 与Map的区别：
        - 首先WeakMap只接收对象作为键名，不接受其他键名作为键名，其次WeakMap的键名所指向的对象，不计入垃圾回收机制。
        - 语法上，一是没有遍历操作（即没有keys()、values()、entries()），也没有size属性。二是无法清空，即不支持clear()方法。因此WeakMap只有四个方法可用：get()、set()、has()、delete()
    - WeakMap 解决了内存泄漏的问题，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。
