# 事件循环
> 主线程从任务队列中读取事件，这个过程是循环不断的，整个的这种运动机制称为EventLoop

# 宏任务和微任务有哪些？
> 宏任务：setTimeout、script、setInterval、I/O、UI render
> 微任务：process nextTick、promise.then、awaite、MutationObserve
> UI render的执行时间：根据HTML standard，在一轮事件循环之后，下一轮循环开始之前进行UI render

# 宏任务、微任务是怎么执行的？
> 先执行同步代码，遇到了异步宏任务则将其放入宏任务对列中，遇到异步微任务则将其放入微任务对列中，当所有的同步代码执行完了，再将异步微任务调入主线程执行，在执行微任务所遇到的新的微任务，会直接加入到此次循环的微任务队列里，微任务执行完毕后再将异步宏任务调入主线程执行，一直到所有任务执行完毕。

# 浏览器和node 的事件循环 区别
- 浏览器内核是多线程的，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下线程组成：
    - GUI渲染线程
    - JavaScript 引擎线程
    - 定时触发线程
    - 事件触发线程
    - 异步 http 请求线程

1. GUI渲染线程
- 主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
- 当界面需要重绘或者由于某种操作引发回流时，将执行改线程。
- 该线程与JS引擎线程互斥，当执行JS引擎时(任务队列不空闲)，GUI渲染会被挂起，当任务队列空闲时，JS引擎才会去执行GUI渲染。

2. JS引擎线程
- 该线程主要是负责处理JavaScript脚本，执行代码。
- 也是主要负责执行准备好待执行的事件，即定时器计时结束，或者异步请求成功并正确返回时，将一次进入任务队列，等待JS引擎线程的执行。
- 该线程与GUI渲染线程互斥，当JS引擎线程执行JavaScript脚本时间过长，将导致页面渲染的阻塞。

3. 定时器触发线程
- 负责执行异步定时器一类的函数的线程，如：setTimeout、setInterval。
- 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计时完毕后，事件触发线程会将计时完毕的事件加入到任务对列的尾部，等待JS引擎线程执行。

4. 事件触发线程
- 主要负责将准备好的事件交给JS引擎线程执行。

5. 异步http请求线程
- 负责执行异步请求一类的函数的线程。
- 主线程依次执行代码时，遇到异步请求，会将函数交给线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程的执行。
由上其实可以看出，JS引擎线程其实就是一条主线，所有的线程都是围绕着他进行着。

## 浏览器中的Event Loop
> script被推入执行栈 -> 同步 -> 异步 直到异步任务的对列被清空 -> 执行渲染操作，更新界面 -> 检查是否存在web woker 任务，如果有对其进行处理。
> 上述过程循环往复，直到两个队列都被清空

## node中的Event Loop
- Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对爱提供统一的API。
- libuv引擎中的事件循环分为六个阶段，它们会按照顺序反复执行。每当进入某一个阶段的时候，就会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一阶段。
    - timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调
    - I/O callbacks 阶段：处理一些上一轮循环中少数未执行的I/O回调
    - idle,prepare阶段：仅node内部使用
    - poll阶段：获取新的I/O事件，适当的条件下node阻塞在这里
    - check阶段：执行setImmediate() 的回调
    - close callbacks阶段：执行socket和close事件回调
以上六个阶段都不包括process.nextTick()
1. timer
timers阶段会执行setTimeout 和 setInterval 回调，并且由poll阶段控制的。同样，`在Node中定时器指定的时间也不是准确时间，只能是尽快执行`
2. poll
poll是一个至关重要的阶段，在这一阶段中，系统会做两件事：
- 回到timer阶段执行回调
- 执行I/O回调
并且在啊进入该阶段时如果没有设定了timer的话，会发生一下两件事情
- 如果poll队列不为空，会遍历回调队列并且同步执行，直到队列为空或者达到系统限制
- 如果poll队列为空时，会有两件事情发生：
    - 如果有setImmediate回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
    - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去
当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

3. check 阶段
setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后。

> Node.js的运行机制如下：
> - v8引擎解析JavaScript代码
> - 解析后的代码，调用Node API
> - libuv库负责Node API的执行。它将不同的任务分配给不同的县城内，形成一个Event Loop，以异步的方式将任务的执行结果返回给V8引擎。
> - V8引擎再将结果返回给用户


# Node 与 浏览器的Event Loop差异
浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。