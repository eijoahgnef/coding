# HTTP
特点：`无连接`、`无状态`、`灵活`、`简单快捷`
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP协议无法根据之前的状态进行本次的请求处理。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

缺点：`无状态`、`不安全`、`明文传输`、`队头阻塞`
- 无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大
- 不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改
- 明文传输：报文(header部分)使用的是明文，直接将信息暴露给了外界，WIFI陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
- 队头阻塞：开启长连接(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态。

## HTTP报文组成
http报文：由`请求报文`和`响应报文`组成
请求报文：由`请求行`、`请求头`、`空行`、`请求体`四部分组成
响应报文：由`状态行`、`响应头`、`空行`、`响应体`四部分组成
- 请求行：包含http方法，请求地址，http协议以及版本
- 请求头/响应头：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等，请求头/响应头每一个字段详解
- 空行：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了
- 请求体：请求的参数
- 状态行：包含http协议及版本、数字状态码、状态码英文名称
- 响应体：服务端返回的数据

# HTTP 的发展史
- 1991年 HTTP/0.9 当时在TCP后就只有请求行的信息，然后服务器接收到信息之后，就会将数据以ASCll字符流返回给客户端
- HTTP/1.0 需求变大了，不再是请求html文件了，还有JavaScript、css、图片、音频等不同类型的文件。因此，此版本引入了请求头和响应头
> 通过请求头，确定服务器返回的数据类型（accept），服务器对数据的压缩方法（accept-encoding），浏览器需要的语言版本（accept-language)，文件的编码类型（accept-Charset）
> 还引入了几个典型的特征：
>- 状态码
>- cahce 机制
>- 服务器需要统计客户端的基础信息，所以在请求头中还加入了`用户代理`的字段。
- HTTP/1.1 
>- 持久化连接  在HTTP/1.0中每进行一次HTTP通信，都要经历TCP连接，传输HTTP数据和断开TCP连接三个阶段。随着一个页面中可能会包含几百个外部引用的资源文件，每次都要经历HTTP/1.0的那三个步骤，无疑会增加大量无谓的开销。所以，`在HTTP/1.1中增加了持久连接的方法，也就是在一个TCP连接上可以传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接。那么该TCP连接会一直保持`
>- 不成熟的HTTP管线化  持久化连接虽然能减少TCP的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果TCP通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的`队头阻塞`的问题。
>- 提供虚拟主机的支持  增加了Host字段，用来表示当前的域名地址，这样服务器就可以根据不同的Host值做不同的处理。
>- 对动态生成的内容提供了完美支持  引入了 `chunk transfer 机制`，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。
>- 客户端cookie、安全机制
- HTTP/2  
> 慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。所以HTTP/2的解决方案为：__一个域名只使用一个TCP长连接和消除队头阻塞问题__。
多路复用的实现：
HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程。
 - 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
 - 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
 - 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
 - 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
 - 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
 - 浏览器接收到响应，会根据 ID 编号将帧的数据提交给对应的请求。

# HTTPS
HTTP + SSL/TLS